// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex, normal;
attribute vec2 texCoord;
attribute vec3 tangent;

uniform mat4 ModelViewProjectionMatrix, normalMatrix;
uniform vec3 lightPos;
uniform sampler2D textureNormal;
uniform sampler2D textureDiffuse;
uniform sampler2D textureSpecular;

varying vec4 vColor;
varying vec2 vTexCoord; 
varying float v_diff;
varying float v_spec;

void main() {
    vec3 viewerPos = vec3(10.0, 0.0, 10.0);
    vec4 vertPos4 = ModelViewProjectionMatrix * vec4(vertex, 1.0);
    vec3 vertPos = vec3(vertPos4) / vertPos4.w;

    vec3 N = normalize((normalMatrix * vec4(normal, 0.0)).xyz);
    vec3 T = normalize((normalMatrix * vec4(tangent, 0.0)).xyz);
    vec3 L = normalize(lightPos - vertPos);
    vec3 V = normalize(viewerPos - vertPos4.xyz);

    T = normalize(T - dot(T, N) * N);
    vec3 B = cross(N, T);

    vec3 normalMap = texture2D(textureNormal, texCoord).rgb * 2.0 - 1.0;

    mat3 TBN = mat3(T, B, N);
    vec3 normalTBN = normalize(TBN * normalMap);
    
    float diff = max(dot(N, L), 0.0);
    float spec = 0.0;

    if(diff > 0.0) {
        vec3 R = reflect(-L, normalTBN);
        spec = pow(max(dot(R, V), 0.0), 80.0);
    }
    
    
    v_diff = diff;
    v_spec = spec;
    vTexCoord = texCoord; 

    gl_Position = vertPos4;
}`;


// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

uniform vec4 color;

uniform sampler2D textureNormal;
uniform sampler2D textureDiffuse;
uniform sampler2D textureSpecular;
varying vec2 vTexCoord; // Receive texture coordinates from the vertex shader
varying float v_diff;
varying float v_spec;

void main() {
     // Ambient
    vec3 ambient = vec3(0.3, 0.00, 0.0);
    // Diffuse
    vec3 diffuse = v_diff * texture2D(textureDiffuse, vTexCoord).rgb;
    // Specular
    vec3 specular = v_spec * texture2D(textureSpecular, vTexCoord).rgb;
    vec3 result = ambient + diffuse + specular;

    gl_FragColor = vec4(result, 1.0); // Use the color computed in the vertex shader
}`;